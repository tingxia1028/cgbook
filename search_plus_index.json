{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这里将以gitbook的形式整理关于computer graphics的一些资料 包括但不限于 读书笔记/总结 网上资源搜集整理 手敲demo的记录 开源引擎源码的学习 商业引擎的使用和开发技能 paper阅读和实现 工作中的思考总结 课程笔记 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 16:41:26 "},"space_trans/resource.html":{"url":"space_trans/resource.html","title":"Space Transformation","keywords":"","body":"Resources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 13:37:40 "},"camera/resource.html":{"url":"camera/resource.html","title":"Camera","keywords":"","body":"Resources GAMES 101 相机与透镜 解释了很多之前学摄影课时其实没有真正理解的东西。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-27 23:02:44 "},"camera/photography/photography.html":{"url":"camera/photography/photography.html","title":"科学解释摄影中的一些概念","keywords":"","body":"科学解释摄影中的一些概念 为啥小于24毫米的被叫做超广角或是鱼眼镜头 --- FOV 为啥画幅越大的相机成像范围越大 手机那么小是如何保证fov的呢 我们常说的曝光是什么 ISO究竟是个啥，为什么调高ISO噪点也变多了 快门到底是咋工作的 如何调节曝光 手机是如何实现变焦的，明明没有什么镜头伸缩的空间啊 景深到底是个啥原理 为什么光圈设置的数值越小反而说光圈越大 跑个题，ray tracing是如何模拟物体相机的 看完了闫兄的那节课，感觉一个爱好摄影的理工科生得到了解脱，就是终于tm的我知道是为啥了。 为啥小于24毫米的被叫做超广角或是鱼眼镜头 --- FOV 为啥画幅越大的相机成像范围越大 手机那么小是如何保证fov的呢 缩短焦距 我们常说的曝光是什么 所以如何控制曝光： 光圈，快门， ISO（熟悉的摄影三要素啊！！！） ISO究竟是个啥，为什么调高ISO噪点也变多了 change the amplification (analog and/or digital) between sensor values and digital image values multiply signal before analog-to-digital conversion 相当于把irradiance线性的乘以一个值，ISO越大乘的倍数越大。 线性乘的时候，噪声也会被线性放大，所以感觉噪点变多了。 快门到底是咋工作的 抬起取景器，放下快门，升起快门 于是可以有motion blur的效果。 rolling shutter的side effect.(果冻效应，讲真感觉不太能get到为什么翻译成果冻效应，并不形象啊) 如何调节曝光 我想要大光圈，又不能过曝，就得减小快门时间。那减少多少的快门时间呢? eg. 光圈 F 2.0 到 光圈 F1.4 1/2.0 -> 1/1.4 ，直径增大差不多是 根号2倍，光圈面积增大2倍，于是快门要缩小2倍，也就是快门时间 * 0.5, 就从1/250 变成 1/500. 手机是如何实现变焦的，明明没有什么镜头伸缩的空间啊 通过一个透镜组来实现不同的焦距。 景深到底是个啥原理 焦距物距像距的关系 理想的薄透镜，根据三角形相似可以得到 Circle Of Confusion(COC) size 模糊效果是跟光圈大小有关系的 Depth of Field 成像清晰的一段范围 COC大小和像素大小差不多的时候是锐利的 sensor离透镜越近，DOF越大，行话景深越小 焦距越小，DOF越大，行话景深越小 光圈直径越小(光圈数值越大, 行话光圈越小)，DOF越大，行话景深越小 COC越大，DOF越大，行话景深越小 为什么光圈设置的数值越小反而说光圈越大 Informal understanding: F number = the inverse-diameter of a round aperture (1/光圈直径) Formal definition: F number = the focal length divided by the diameter of the aperture （f/光圈直径） 所以光圈越大，DOF越小，模糊的范围越大，行话说景深越大。 跑个题，ray tracing是如何模拟物体相机的 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-28 00:39:03 "},"ray_tracing/resource.html":{"url":"ray_tracing/resource.html","title":"Ray Tracing","keywords":"","body":"Resources Entry Level 闫令琪的games101 lecture 13 - 16 很好的一门CG基础课程，看视频比较容易看的进去 Peter Shirley 的入门三部曲，很适合初学者，并且一定要跟着手敲一遍，会加深理解 Ray Tracing in One Weekend Ray Tracing: The Next Week Ray Tracing: The Rest of Your Life courses Utah CS6620 Fall 2019 Ray Tracing for Graphics 虽然没有课件，但是课后作业设计的不错 UCSD CSE168 computer graphics 2 : rendering 介绍了rt的一些基础知识, 感觉看课件pdf就可以没必要看视频 UCSD CSE 272: Advanced Image Synthesis 更偏离线渲染，可以看做CSE168的进阶课程，看看课件，配合课程提供的mini离线渲染器lajolla Renderer做一做作业还是不错的 Advanced Level NVDIA出品的Ray Tracing Gems DirectX Raytracing introduction and a demo Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-02-08 11:56:08 "},"ray_tracing/sampling/resource.html":{"url":"ray_tracing/sampling/resource.html","title":"Sampling","keywords":"","body":"Resources RTR Chapter13, Monte Carlo Integration Unity 18, Sampling the GGX Distribution of Visible Normals Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-07-19 11:37:26 "},"ray_tracing/sampling/montecarlo/montecarlo.html":{"url":"ray_tracing/sampling/montecarlo/montecarlo.html","title":"Monte Carlo Integration","keywords":"","body":"Monte Carlo Integration why Monte Carlo Integration Background and Probability Review canonical uniform random variable variance The Monte Carlo Estimator Sampling Random Variable The Inversion Method The Rejection Method Metropolis Sampling main ideas example estimate integrals disadvantages Transforming between Distributions 2D Sampling with Multidimensional Transformations 如何提高积分器的效率 efficiency of an estimator Russian Roulette and Splitting Russian Roulette splitting Careful Sample Placement Stratified Sampling Quasi Monte Carlo 引入bias Importance Sampling 这篇笔记整体的逻辑是： 我想估计一个积分值，有哪些方法, 为什么Monte Carlo Integration可以脱颖而出 Monte Carlo Integration是个啥原理 --- Monte Carlo estimator 给定了一个Monte Carlo estimator，我应该如何得到samples 如何评估一个Monte Carlo estimator的好坏 怎样让自己的Monte Carlo estimator更好 why Monte Carlo Integration 相比于rapezoidal integration or Gaussian quadrature, Monte Carlo integration makes it possible to estimate the reflected radiance simply by choosing a set of directions over the sphere, computing the incident radiance along them, multiplying by the BSDF’s value for those directions, and applying a weighting term. The main disadvantage of Monte Carlo is that if n samples are used to estimate the integral, the algorithm converges to the correct result at a rate of O(n^(1/2)). Most of the current research in Monte Carlo for computer graphics is about reducing this error as much as possible while minimizing the number of additional samples that must be taken. Background and Probability Review canonical uniform random variable 均匀随机采样重要的原因是： it is easy to generate a variable with this distribution in software it is possible to generate samples from arbitrary distributions by first starting with canonical uniform random variables and applying an appropriate transformation variance Variance is a fundamental concept for quantifying the error in a value estimated by a Monte Carlo algorithm. It provides a precise way to quantify this error and measure how improvements to Monte Carlo algorithms reduce the error in the final result. The Monte Carlo Estimator estimator --- approximates the value of an arbitrary integral unbias independent of the sample nums N and the dimensionality of the integral rate of convergence O(n^(1/2)) Sampling Random Variable The Inversion Method 等于是计算出cdf, 然后以一个均匀随机采样去获得[0,1]的随机数 y，然后反算出cdf(x) = y的x值是多少作为采样值。 The Rejection Method Metropolis Sampling a technique for generating a set of samples from a non-negative function that is distributed proportionally to f ’s value (Metropolis et al. 1953). main ideas start-up X_0 make mutation from X_i-1 to X_i --- transition function T 和前一个sample有关 和前一个sample无关，随机 weather new X_i is accepted --- acceptance probability a final target --- equilibrium pseudocode example 上面的理论听起来还是太抽象，用实际的例子来理解是最好不过的。 为了拟合以下概率密度函数，采用两种mutation的方式 uniform random ---- 不会一直陷入一个small region出不来 random offset --- 收敛速度更快，方差小 comparison estimate integrals 其实这里没太懂。。。这里的近似有点像之前games202里说的chebyshelve不等式近似。 disadvantages successive samples in the sequence are statistically correlated, and it may needs more samples so can well distributed across the domain. Transforming between Distributions 我们通常是用一种简单好采样的distribution(eg. uniform random)去转换到目标的distribution上，那这个转换函数怎么得到？ 一维 转换函数必须是一种 one-to-one transformation： 推广到多维 联想到render equation最常用的半球积分 2D Sampling with Multidimensional Transformations 基本的思想是 先根据p(x)得到x的一个sample，再根据p(y|x)分布得到y的一个sample. 以均匀球面采样为例 求得cdf，求逆，得到均匀采样如何转换到均匀球面采样 Malley’s method --- 正好带到之前看SSR的GGX visible normal中的采样方法 就是把单位球的cos(theta)分布采样转换成单位圆的采样 而单位球上的均匀采样正好也满足同样的概率分布 如何提高积分器的效率 https://zhuanlan.zhihu.com/p/82984446 通过构造一个近似原被积函数的新函数的解析积分方法。 通过在积分域中合理分布采样点。 通过在采样过程中获得的信息适应性控制采样密度。 通过结合来自不同估计的结果。 efficiency of an estimator variance time Russian Roulette and Splitting Russian Roulette 目标是无偏地 skip tracing unimportant rays. 通常c=0 但是问题是Russian Roulette会增大方差。 splitting increases the number of samples taken in order to improve efficiency Careful Sample Placement 讨论了减少方差的一些方法 Stratified Sampling 基本原理就是把积分区域分成n nonoverlapping regions, 在每个region里再进行采样。 Quasi Monte Carlo they replace the pseudo-random numbers used in standard Monte Carlo with low-discrepancy point sets generated by carefully designed deterministic algorithms. 引入bias 改成有偏估计但是方差更小 Importance Sampling 采样的概率密度分布尽可能的接近原函数。 eg. if directions are sampled from distributions that match other factors of the integrand (the BSDF, the incoming illumination distribution, etc.), efficiency is similarly improved. 一个粗糙的证明： Multiple Importance Sampling 多个函数相乘的积分估计是更加困难的，因为不是简单的分别采样就可以得到一个好的结果，有的时候错误的分布采样得到的结果甚至比随机均匀采样还要糟糕。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-01 18:43:58 "},"ray_tracing/denoising/resource.html":{"url":"ray_tracing/denoising/resource.html","title":"Denoising and Filtering","keywords":"","body":"Resources non-DL based denoising REBLUR REBLUR, ray tracing gems 2 chapter 49: A Hierarchicle Recurrent Denoiser REBLUR GTC2020 talk SVGF SVGF: Spatiotemporal Variance-Guided Filtering ReLAX: A Denoiser Tailored to Work with the ReSTIR Algorithm ReLAX originates from SVGF but takes image quality and performance to the next level. DL based denoising Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-11 16:36:01 "},"ray_tracing/intersection_acceleration/resource.html":{"url":"ray_tracing/intersection_acceleration/resource.html","title":"Intersection Acceleration Structure","keywords":"","body":"Resources BVH SDF HZB Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-02-08 11:50:44 "},"volume/resource.html":{"url":"volume/resource.html","title":"Volume Rendering","keywords":"","body":"Resources Production Volume Rendering SIGGRAPH 2017 Course 将volume rendering加入到path tracing中，目前只看了volume rendering的理论知识部分，讲的挺好的 siggraph15, Frostbite Physically-based & Unified Volumetric Rendering Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-21 18:04:44 "},"volume/volume_rendering/volume_rendering.html":{"url":"volume/volume_rendering/volume_rendering.html","title":"Volume Rendering Basic Theory","keywords":"","body":"Volume Rendering Basic Theory Volume Rendering Basic Theory properties of volumes light propagation in volumes discrete methods properties of volumes what are volumes Volumes, are collections of particles, ranging from atoms and molecules to any particle size. collision probability the chance of a photon collision probability density of collision per unit distance deﬁned by a coeﬃcient σ(x), which is the probability density of collision per unit distance traveled inside the volume. The physical unit of a collision coeﬃcient is inverse length. mean free path the average distance traveled between collisions. light propagation in volumes radiative transformation equation(RTE) what happens to a radiance beam as it travels forward absorption out-scattering emission in-scattering RTE Volume Rendering Equation(VRE) describes the radiance in terms of where it comes from discrete methods 积分转换成离散求和，沿一个方向ray marching来累积。 这部分待推导 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 19:07:44 "},"GI/resource.html":{"url":"GI/resource.html","title":"GI","keywords":"","body":"Resources contents note GI draft 真的是从啥也不会开始初步的了解各个算法流派以及现有的resolution，只能当成是一个简单的目录索引去看，涉及到的算法细节其实没有完全搞清楚。列举了每种算法的基本原理和相应resolution以及各自的优缺点，真的是非常小学生的“调研报告”了。 Precomputed Based GI 基于预计算的GI. Voxel Based GI 基于体素的GI, 包括了算法原理的笔记，demo实现的记录等。 books 秦春林 的 全局光照技术 涉及到的GI算法比较全，且是中文的，看起来比较没有那么费力 lessons 闫令琪的Games201课程 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-07 21:04:04 "},"GI/GI_draft/GI_draft.html":{"url":"GI/GI_draft/GI_draft.html","title":"GI Draft","keywords":"","body":"GI draft 什么是GI 先验知识 radiometry render equation 主要思路 最直观的思路 ——— ray tracing type 把耗费性能的计算提前处理 ——— precomputed type 减少光照计算的geometry粒度 GI data的存储 基本流派 ray tracing basic theory solutions photon mapping basic theory solutions instant radiosity solutions Light Propagation Volumes GI basic theory solutions radiosity basic theory solutions voxel based basic theory solutions screen space GI basic theory solutions GI数据存储 现有的解决方案 Enlighten features 优点 缺点 NVDIA　VXGI features CryEngine SVOGI features Current Limitations DXR GI 优点 缺点 UE4 LPV features 什么是GI Global illumination (GI) is a family of algorithms that simulate how light interacts and transfers between objects in a scene. 简单的理解就是 GI = direct lighting + indirect lighting, 产生包括漫反射，高光，镜面反射，散射，焦散，阴影等效果。 Direct lighting较为简单，所以以下的技术主要都是针对indirect lighting的计算。 先验知识 radiometry radiant energy & radiant flux radiant intensity 每单位立体角上的radiant flux irradiance 每单位照射面积所接收到的radiant flux radiance 每单位立体角，每单位垂直面积的radiant flux. render equation basic equation a kind of BRDF extension 主要思路 最直观的思路 ——— ray tracing type tracing from camera tracing from light tracing from both camera and light photon mapping instant radiosity 把耗费性能的计算提前处理 ——— precomputed type 对光照传输过程进行预计算 precompute各个方向的入射光radiance environment map precompute irradiance即各个方向入射光radiance的积分值 prefiltering precompute 可见性和入射光余弦项对应的积分 PRT 对光照结果进行预计算 precompute除去Kd和Ks剩余积分项 减少光照计算的geometry粒度 把场景的表面细分成一些粒度较大的面片 radiosity 计算场景中空白位置的光照信息，物体的光照由这些位置的结果计算 light probe 把3d空间划分成一些子集，以子集的光照信息作为代表 voxel 将计算限制在屏幕空间 screen space GI GI data的存储 lightmap cubemap spherical harmonics spherical guassian 基本流派 ray tracing basic theory path tracing 基本算法步骤 选择一个光线，给定参数（x,y,u,v,t） 找到与这个光线最近的一个表面交点处 随机决定是否计算发射(emitted)或反射(reflected)光。 如果计算发射光：返回 weight Le。 如果计算反射光：weight = reflectance，BRDF pdf随机散射，返回第二步。 算法在path到达光源时终止。 solutions DXR GI frosbite photon mapping basic theory 基本算法步骤 构造photon map 光子从光源发射到场景中。一旦光子和一个几何面相交，相交点和入射方向就会被存在一个叫光子贴图（photon map）的缓存中。 利用photon map计算辐射度 用nearest neighbor搜索函数搜索光子贴图，收集临近区域的N个光子 构造一个球体S，把得到的这N个光子包围起来 对每个光子，根据S和BRDF，计算其光通量能量 所有光子的贡献总和将为相交点的辐射强度 三种类型的photon map caustics photon map global photon map volume photon map solutions real-time GI with photon mapping instant radiosity basic theory 基本算法步骤 从光源上产生N个粒子 从光源打出很多light sub-path，这些光会停在某些地方，就认为它停在的地方就变成了新的虚拟点光源光源（VPL) VPLs可以存在一张Reflective Shadow Map(RSM)中 用新的VPL计算光照 可以采用光栅化，ray tracing或是其他方法。 solutions Instant Radiosity for Real-Time Global Illumination Light Propagation Volumes GI basic theory 本质上是instant radiosity结合radiance volume的思想。 基本的算法步骤 solutions UE4 : LPV CryEngine radiosity basic theory 基本的算法步骤 对场景的表面进行曲面细分 计算两两曲面之间的form factors 求解radiosity matrix(迭代法) 初始数据为直接光照结果 计算每个pixel的光照 incremental radiosity会在材质或者物体位置等发生变化时动态更新form factors和radiosity solutions frosbite 2010 enlighten voxel based basic theory 基本的算法步骤 将场景体素化 构建数据结构 SVOGI 构建八叉树管理体素 VXGI 构建clipmap 对体素的着色参数进行预过滤 cone tracing visibility 25%=50% x 50% reference 腾讯游戏学院 知乎 简单的实现 solutions VXGI CryEngine : Sparsed Voxel-based Global Illumination (SVOGI) screen space GI basic theory SSDiffuse 基本的算法步骤 1.采样不同lod的深度图信息并得到其中最大的深度值。（要执行多少次寻找就看你设置多少次pass） 2.用ray marching的方式，并用噪音图采样以圆的周长来找周围的像素点的颜色，这个颜色是根据当前场景颜色做的（所以ssgi一般放到最后处理）。采样的点存储到rt上 3.这时的rt是带有比较明显的锯齿的rt，需要用taa方式过滤一次 4.最后在横向和纵向做两次模糊处理。 5.这样就得到了ssgi的漫反射方向的间接光照了，最后只需要把场景图和这个间接光rt combine一下就好了。 SSR solutions UE4 SSGI GI数据存储 light maps spherical harmonics Spherical harmonics from offline photon mapper Texel has irradiance at surface point, as a continuous function on a sphere Probes for dynamic objects also stored as SHs SH: Great for diffuse, but specular 适合存储低频的信息 spherical guassian Approximate incoming radiance using spherical gaussians Intuitive & compact representation for diffuse and specular Probes for dynamic objects also stored as SGs Extensive implementation details on Matt’s blog [Pettineo16] 现有的解决方案 Enlighten Enlighten calculates the effect of global illumination in real-time. Lights, materials and objects can be moved and updated at runtime with the global illumination updating in milliseconds. Enlighten makes use of both lightmaps and light probes to enable efficient rendering. Probes makes lighting of complex meshes with very many small features, such as foliage, are more efficiently lit using probes. features light maps and light probes iterate fast Enlighten continuously updates global illumination in the background dynamic world outdoor, innerdoor... real-time reflections, even for off-camera objects emissive surfaces will have almost zero performance cost 优点 独立的SDK 支持多个平台, mobile, pc, console, VR 比较成熟的商业化产品，迭代解决了很多问题 缺点 CPU计算，因此免不了在GPU-CPU之间更新数据 enlighten不能够很好处理场景被破坏，结构改变等时候的光照变化情况 贵！！ NVDIA　VXGI It provides means to quickly compute a voxel representation of a mesh scene and use that representation with Voxel Cone Tracing for diffuse and specular global illumination, ambient occlusion, and high-quality area lighting. features Indirect diffuse and specular interreflections High-quality planar area lights with soft shadows Large-scale, stable ambient occlusion Dynamic and procedural geometry Dynamic lights and emissive materials Virtual Reality support, including MRS and LMS CryEngine SVOGI features Dynamic indirect light bounce from static and most of dynamic objects. Large scale AO and indirect shadows from static geometry (vegetation, brushes and terrain). Works without pre-baking and does not require manual setup of many bounce lights or light volumes. Current Limitations Large scale AO and indirect shadows may be cast properly only by static geometry. GI is not working on some forward rendering components like particles or water. Some artifacts like ghosting, aliasing, light leaking and noise may be noticeable in some cases. Procedural vegetation and merged vegetation do not cast occlusion or secondary shadows. If the camera is teleported to a completely new location it may take up to a few seconds until occlusion is working properly. Only objects and materials with enabled shadow map casting may produce proper bounced light. For dynamic objects indirect light bounce is working only in the areas near voxelized static geometry. Bounce light may have a noticeable delay of 1-2 frames. r_Supersampling = 2 makes GI look strange but setting lower LowSpecMode (2X lower) pretty much restores the look and speed. Temporal AA (r_AntialiasingMode 2/3) works just fine. DXR GI provides scalable solutions to compute multi-bounce indirect lighting without bake times, light leaks, or expensive per-frame costs. 优点 室内外及室内。RTX可避免漏光。 游戏运行时。RTX GI可保障性能，可跨GPU扩展，分辨率高达4K，且无噪点。 游戏制作。RTX GI可告别烘焙耗时，无需每探头调优，并能够加速当前光照探针工作流程和专业度的提升。 任何光照类型：RTX GI可针对点、线、面积照明、天空盒照明和发光物体自动展开工作。 引擎：RTX GI可升级现有光照探针引擎数据路径和工具。 内容创建：RTX GI采用完全动态的场景，无需人工干预。 可扩展性：一条代码路径即可实现所有，从能够避免旧有遗留平台漏光现象的烘焙光照探针，价格较低的GPU上慢慢更新的运行时GI，到发烧友级GPU上的即时动态GI。它能够在发挥高端PC强大功能的同时提供广泛的支持。 缺点 每个级联5MB GPU RAM，所有级联和中间层峰值均为20MB 在固定时间模式下，1-2毫秒/帧可获最佳性能，在超高固定画质模式下，1-2 Mray/帧可获最佳性能（在2080 Ti上亦如此） 在针对其他效果（如光面和阴影光线）使用光线追踪时，可最大限度地减少开销。 在画面开发和制作早期就应引入RTX GI。GI能够极大程度上改变光照，比直射光需要更多符合物理原理的几何图形和调优，也为游戏领域带来了全新机遇。 基于低端GPU则光照流速较慢（世界-空间延迟，无屏幕-空间重影） 阴影图类的偏置参数必须调优至场景比例。 无法防止零厚度/单面墙漏光 必须与另外的光面全局照明解决方案（如屏幕-空间光线追踪、去噪几何光线追踪或环境探针）配合使用。 UE4 LPV features Computed each frame which allows dynamic material/light/geometry. Diffuse and approximated specular material interaction. Limited distance (larger volume e.g. 2x would be easy but memory requirements and some computations would grow by 8x). Constant detail in world space (it would be better to have more detail nearby and less detail in distance). Not affecting translucency. Light bounce is not affected by decals. Decal shading just works (unlike with baked lighting where the lighting is applied in the base pass before decals get applied). Requires compute shader (DirectX 11) support. Supports one or more Directional light for light bounce. Changing the size at runtime has minor artifacts that fade away over time. Emissive lighting for cheap area lights (not currently implemented). Occlusion (not currently implemented). Point light shadows approximated by occlusion (not currently implemented). Secondary occlusion through geometry voxelization which has some performance cost but quite better quality (not currently implemented). 杂 Ray tracing 光线追踪 Path tracing 路径追踪 Photon mapping 光子映射 Point Based Global Illumination 基于点的全局光照 Radiosity 辐射度 Metropolis light transport 梅特波利斯光照传输 Spherical harmonic lighting 球谐光照 Spherical Gaussian lightmaps Ambient occlusion 环境光遮蔽 Voxel-based Global Illumination 基于体素的全局光照 Light Propagation Volumes Global Illumination Deferred Radiance Transfer Global Illumination Deep G-Buffer based Global Illumination screen space GI RRS category 1 : features diffuse GI specular GI ambient occlusion area lighting category 2 precompute lighting precomputed radiance transfer real-time Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 16:19:08 "},"GI/ssgi/resource.html":{"url":"GI/ssgi/resource.html","title":"SSGI","keywords":"","body":"Resources SSR SSGI theory 14, Efficient GPU Screen-Space Ray Tracing sig15, frosbite, Stochastic Screen-Space Reflections sig17, Optimized pixel-projected reflections for planar reflectors GPU pro, Hi-Z Screen-Space Cone-Traced Reflections implementations unity stochastic SSR unity tick SSGI compute stochastic SSR AMD Stochastic SSR Xerxes1138, stochastic SSR Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-08 10:13:50 "},"GI/precompute/resource.html":{"url":"GI/precompute/resource.html","title":"Precomputed Based GI","keywords":"","body":"Resources PRT(precomputed radiance transfer) Ravi Precomputation-Based Rendering 顶牛Ravi大佬介绍precompution的课件。 sig02, Precomputed Radiance Transfer for Real-Time Rendering in Dynamic, Low-Frequency Lighting Environments lightmaps Frosbite18, path-traced SH lightmaps Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-14 15:28:44 "},"GI/voxel_based/resource.html":{"url":"GI/voxel_based/resource.html","title":"Voxel Based GI","keywords":"","body":"Resources paper Crassin 2011 Interactive Indirect Illumination Using Voxel Cone Tracing voxel数据结构基于sparse octree McLaren 2015 The tomorrow children: lighting and mining with voxels voxel数据存储在多级3D texture mipmap中，渲染的时候基于texture cascade的思路去采样。 demo https://wickedengine.net/2017/08/30/voxel-based-global-illumination/ Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 22:17:30 "},"GI/distance_field/resource.html":{"url":"GI/distance_field/resource.html","title":"Distance Field","keywords":"","body":"Resources UE4 distance field doc Youtube, Understanding the SDF Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-02-04 15:45:45 "},"pbr/resource.html":{"url":"pbr/resource.html","title":"PBR","keywords":"","body":"Resources Disney 12, Physically Based Shading at Disney. Physically Based Shading in Film and Game Production, ACM SIGGRAPH 2012 Courses Filament UE4 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-01 20:29:13 "},"pbr/material/resource.html":{"url":"pbr/material/resource.html","title":"Material","keywords":"","body":"Resources BSDF models diffuse reflectance specular reflectance NDF 毛星云，基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结 geometry function 毛星云，基于物理的渲染（PBR）白皮书】（五）几何函数相关总结 Uber BSDF Disney BSDF 2012 Siggraph course, Physically Based Shading at Disney (Brent Burley) 2015 Siggraph course, Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering (Brent Burley) Autodesk Standard Surface Unreal Engine 4 Physically-based Material Substance’s Physically-Based Shaders PBR guide hair skin cloth Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-03-09 15:59:17 "},"pbr/material/reflection_models/reflection_models.html":{"url":"pbr/material/reflection_models/reflection_models.html","title":"Reflection Models","keywords":"","body":"Reflection Models Reflection Models reflection models categories geometric settings specular reflection and transmission Fresnel Reflectance --- amount of reflection Index of refraction 定义 two dielectric media a conductor and a dielectric medium semiconductors (not included) specular reflection specular transmission Lambertian Reflection Microfacet Models Oren–Nayar Diffuse Reflection main thoughts model Normal Distribution Function Beckmann and Spizzichino Model Trowbridge and Reitz Model comparison Masking and Shadowing Smith masking-shadowing function G_1(w, w_h) Beckmann–Spizzichino distribution Trowbridge–Reitz distribution both direction geometry function G(w_o, w_i) independently for w_o, w_i dependently The Torrance–Sparrow Model basic thoughts Torrance–Sparrow BRDF Torrance-Sparrow BRTF Fresnel Incidence Effects basic principle Ashikhmin and Shirley model glossy specular term diffuse term FourierBSDF objective represents isotropic BSDFs specified BSDF value Catmull–Rom spline interpolation reflection models categories diffuse glossy specular perfect specular retro-reflective eg. velvet 天鹅绒geometric settings specular reflection and transmission 镜面反射 遵从 Snell’s law的透射 理论上，the index of refraction varies with the wavelength of light (eg. 色散), 但是为了简化，忽略波长的因素 Fresnel Reflectance --- amount of reflection Index of refraction 定义 the ratio of the speed of light in a vacuum to the speed of light in the medium. two dielectric media index of refraction complex index of refraction --- absorption a conductor and a dielectric medium semiconductors (not included) specular reflection specular transmission Fresnel现象：transmission is stronger at near-perpendicular angles Lambertian Reflection models a perfect diffuse surface that scatters incident illumination equally in all directions const Spectrum R gives the fraction of incident light that is scattered BRDF f = R / pi (pi 是 cos(theta)在半球上的积分) Microfacet Models rough surfaces can be modeled as a collection of small microfacets a representation of the distribution of facets a BRDF that describes how light scatters from individual microfacets Oren–Nayar Diffuse Reflection main thoughts real-world objects do not exhibit perfect Lambertian reflection describes rough surfaces by V-shaped microfacets described by a spherical Gaussian distribution with a single parameter theta, the standard deviation of the microfacet orientation angle. model Normal Distribution Function NDF必须归一化 Beckmann and Spizzichino Model isotropic anisotropic Trowbridge and Reitz Model comparison Trowbridge–Reitz has higher tails—it falls off to zero more slowly for directions far from the surface normal. This characteristic matches the properties of many real-world surfaces well. Masking and Shadowing Smith masking-shadowing function G_1(w, w_h) 必须满足归一化条件 basic thoughts forward-facing facets 的投影面积 减去 backward-facing facets的投影面积 auxiliary function Beckmann–Spizzichino distribution assume that there is no correlation between the heights of nearby points on the microsurface function a rational polynomial approximation Trowbridge–Reitz distribution both direction geometry function G(w_o, w_i) independently for w_o, w_i dependently microfacet visibility is more likely the higher up a given point on a microfacet is The Torrance–Sparrow Model basic thoughts modeled surfaces as collections of perfectly smooth mirrored microfacets only consider the half vector. Torrance–Sparrow BRDF perfect specular reflection Torrance-Sparrow BRTF perfect specular transmission Fresnel Incidence Effects basic principle 这个关心的是上一层材质的Fresnel reflection是如何影响下一层材质的入射光照的。 Fresnel reflection reduces the amount of light that reaches the bottom level of layered objects. Ashikhmin and Shirley model models a diffuse underlying surface with a glossy specular surface above it. glossy specular term diffuse term R_d diffuse surface reflectance, R_s specular surface reflectance FourierBSDF objective 一些复杂的材质很难用一个通用BXDF公式去描述。 一种思路是存a large 3D or 4D lookup table，但是这样数据量会太大。 想要寻求的是a more compact representation that still represents the BSDF accurately， FourierBSDF就是这样的一个解决方案。 核心思想是sums of scaled cosine terms using the Fourier basis. represents isotropic BSDFs 因为isotropic，所以有对称性，所以没有sin项。 specified BSDF value 找到临近的离散值，做一定的插值得到Fourier系数，然后计算BSDF值。 Catmull–Rom spline interpolation objective 对于一个function f, 对每一段区间[x_i, x_i+1]希望用a cubic polynomial来拟合这个函数： 使得这个多项式满足 calculation 因为原函数未知，导数不好求所以用近似的方法 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-03-02 16:42:21 "},"pbr/lighting/resource.html":{"url":"pbr/lighting/resource.html","title":"Lighting","keywords":"","body":"Resources light units light sources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 09:25:34 "},"pbr/lighting/filament_base_lighting/filament_base_lighting.html":{"url":"pbr/lighting/filament_base_lighting/filament_base_lighting.html","title":"Filament Basic Physical Lighting","keywords":"","body":"Filament Basic Physical Lighting light units (统一度量衡) luminous intensity 和 illuminance 的转换关系 direct Lighting directional light diffuse almost correct, but specular has artifacts E⊥ is the illuminance of the light source for a surface perpendicular to said light source punctual light point light 球面积分的式子应该少了一项sin(theta)项 spot light 但是为了方便artist调节参数，需要把outer angle和perceived illuminance解耦，近似成 但是也仅限于a matte, diffuse mask that absorbs light的材质才近似物理正确。 最终，spot light 的 render equation有如下形式： attenuation function 但其实point light和spot light并不遵循inverse square law attenuation. Photometric lights 如何给artist更大的自由去控制the distribution of light within the space. Photometric lights use a photometric profile to describe their luminous intensity distribution. IES (Illuminating Engineering Society) EULUMDAT (European Lumen Data format) 比punctual light多一项各个方向采样的intensity IES profile生成pass使用的a photometric profile as a texture的两种方式： - Photometric profile as a mask - Photometric profile float multiplier; // Photometric profile used as a mask if (photometricLight.isMasked()) { // The desired intensity is set by the artist // The integrated intensity comes from a Monte-Carlo // integration over the unit sphere around the luminaire multiplier = photometricLight.getDesiredIntensity() / photometricLight.getIntegratedIntensity(); } else { // Multiplier provided for convenience, set to 1.0 by default multiplier = photometricLight.getMultiplier(); } // The max intensity in cd comes from the IES profile float lightIntensity = photometricLight.getMaxIntensity() * multiplier; Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 11:08:28 "},"light/resource.html":{"url":"light/resource.html","title":"Light","keywords":"","body":"Resources punctual light Real-TIme Rendering, chapter 5.2, Light Sources area light Unity, Real-Time Polygonal-Light Shading with Linearly Transformed Cosine Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 11:55:13 "},"light/punctual/punctual.html":{"url":"light/punctual/punctual.html","title":"Punctual Light","keywords":"","body":"Punctual Light Punctual Light 守时的光源？？ light direction Point/Omni Light attenuation singularity problem self-defined attenuation function large distances calculation Spot Light Others 守时的光源？？ 最开始看到punctual light的时候查了下字典，punctual是守时的精确的，再带进去实在是很费解。然后看了RTR这本书的对应章节才明白： We use the term “punctual,” from the Latin punctus meaning “point,” for the class consisting of all sources of illumination that originate from a single, local position. light direction Point/Omni Light attenuation 其实主要是想看看这个衰减函数的，因为上周在分享一篇关于点光衰减函数的时候会发现在到光源距离r无限小的时候，光强会趋于无穷大，就会有点费解，那点光的intensity的定义究竟是什么，然后在书里找到了答案： 点光的衰减函数就是距离平方的倒数，通常我们定义的点光的intensity实际是在某个给定距离下的intensity. 这样一说就觉得比较合理了。 singularity problem 距离平方的倒数的衰减函数就会面临一个除0的问题，以下会有一些解决办法： 分母加上一个很小的数 UE 的DeferredLightingCommon.ush里实现是取的1 cm. 距离做截断 CryEngine and Frostbite 是这么做的，it has a physical interpretation: the radius of the physical object emitting the light, 这里考虑了光源的物理半径。 siggraph 2020 talk http://www.cemyuksel.com/research/pointlightattenuation/ 作者把点光近似为一个spherical disk light, 把距离的attenuation转换成立体角的大小。 在距离比较小的时候对inverse squared有更好的近似。 self-defined attenuation function 对于有些场景，拟合inverse-square curve没有那么必要，就可以根据需要定义自己的衰减函数： large distances calculation 距离比较远了之后，点光衰减的很多几乎接近于0，从性能上考虑，这部分计算性价比就不高了。 和一个 windowing function 相乘 UE 和 Frostbite 都用的窗口函数是（unreal 里的 attenuation radius就是r_max）： Spot Light spot light相比点光还多了一个方向上的衰减函数。 Frosbite 中使用的函数 Others IES profiles falloﬀ functions for distance along the x, y, and z world axes vary light intensity over time Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 11:56:40 "},"color/resource.html":{"url":"color/resource.html","title":"Color","keywords":"","body":"Resources 一个很好的介绍Color相关的系列博客 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-03-09 16:10:11 "},"shadow/resource.html":{"url":"shadow/resource.html","title":"Shadow","keywords":"","body":"Resources real-time rendering chapter 7 games202 lesson 3-5 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-17 15:01:40 "},"shadow/shadow_summary/shadow_summary.html":{"url":"shadow/shadow_summary/shadow_summary.html","title":"Real-Time Shadow Summary","keywords":"","body":"real-time shadow summary 补点常识吧 basic things soft shadow The math behind shadow mapping state of art projection shadow projective texture mapping shadow volume shadow maps basic principle shadow map problems and solutions 软阴影 PCF(Percentage-Closer Filtering) PCSS(Percentage-Closer Soft Shadows) filtered shadow map VSM(Variance Shadow Map) CSM (Convolution Shadow Mapping) & ESM(Exponential Shadow Map) Moment Shadow Mapping SDF(Signed Distance Field) volumetric shadow technique transparency depth map deep shadow maps opacity shadow maps，adaptive volumetric shadow maps， 补点常识吧 basic things https://www.youtube.com/watch?v=AbyHtfDG8ME light luminous object transparent, translucent and opaque objects light travels a straight way occlusion cause shadowsoft shadow https://blog.demofox.org/2017/07/01/why-are-some-shadows-soft-and-other-shadows-hard/ soft shadow 并不是简单的边缘blur, 从形成原理上看umbra和距离光源的远近还有光源的大小都有关系 The math behind shadow mapping state of art projection shadow simply apply this matrix to the objects that should cast shadows on the plane π, and render this projected object with a dark color and no illumination. 考虑可能存在的问题： 阴影绘制在了平面的下面 --> 绘制顺序 or shadow map ground plane有边界，阴影绘在了边界外 --> stencil 光源处于shadow caster和receiver之间导致anti-shadow --> projection with clipping soft shadow 面光源采样得到一个punctual light, 渲染阴影，sum and average 通过filtering去blur hard shadow renders the silhouette edges with gradients that go from dark in the center to white on the edges projective texture mapping the occluder is rendered in black from the light’s viewpoint into an otherwise white texture. 以上两个projection的方法存在的问题： identify which objects are occluders and which are their receivers occluding objects cannot shadow themselves shadow volume the count is incremented as a ray passes through a frontfacing triangle of a shadow volume and decremented on leaving through a backfacing triangle. 两个pass： 一个pass只画front face，更新stencil buffer +1 一个pass只画back face，更新stencil buffer-1 存在的问题： 每个三角面片都要生成一个shadow volume计算量太大 受视角方向和光照方向影响很大 shadow maps basic principle from the light's point of view. texture DEPTH textures are usually of 24bits but they could be of 32bits encode the depth as a color //coverts a value from [0..1] into RGBA vec4 PackDepth32( in float depth ) { depth *= (256.0*256.0*256.0 - 1.0) / (256.0*256.0*256.0); vec4 encode = fract( depth * vec4(1.0, 256.0, 256.0*256.0, 256.0*256.0*256.0) ); return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0/512.0; } //coverts a RGBA into a float [0..1] float UnpackDepth32( in vec4 pack ) { float depth = dot( pack, 1.0/vec4(1.0, 256.0, 256.0*256.0, 256.0*256.0*256.0) ); return depth * (256.0*256.0*256.0) / (256.0*256.0*256.0 - 1.0); } shadow view --> shadowmap camera viewprojection matrix directional light orthographic view spot light perspective view poInt light cube map, 6 times perspective view reprojecting to shadow map when projecting a point using a projection matrix the result is in homogeneous coordinates, and we need to divide by the resulting .w to pass to clip-space coordinates. comparing depth dx11 sampleCmp 可以在采样的时候进行比较输出[0,1]的值 shadow map problems and solutions shadow acne slope scale bias Bias根据物体的normal和光照方向夹角决定，夹角越小，bias越小。 normal oﬀset bias 预先将物体的position延normal方向移动一个bias，bias和normal和光方向夹角成正比。 light leaks / peter panning front face culling perspective aliasing and projective aliasing 离viewer更近的区域在shadow map使用更多的采样 增大shadow map的resolution matrix-warping techniques 更改light的camera的参数 PCM(Perspective Shadow Maps) Light Space Perspective Shadow Maps(LiPSM) Trapezoidal Shadow Maps(TSM) cascade shadow 软阴影 PCF(Percentage-Closer Filtering) retrieving multiple samples from a shadow map and blending the results, to ﬁnd the percentage of the samples taken that are visible to the light. PCF会考虑以下几个variations 采样范围大小 采样数 采样点如何选取 采样结果权重 通常，采样randomly rotated Poisson distribution可以得到比较好的效果。 PCSS(Percentage-Closer Soft Shadows) 基于的主要假设是the average blocker is a reasonable estimate of the penumbra size. The average distance of these occluders from the location is used to determine the sample area width. The width of the surface area to the sample grows as the average occluder gets farther from the receiver and closer to the light. filtered shadow map VSM(Variance Shadow Map) 基本假设 receiver是一个平面。 基本原理 得到一个an upper bound on the visibility percentage of the receiver. 为了提升PCF的第三步的效率。 这个不等式理论上只有t在均值的右侧才正确。 PCSS第一步中的the average depth of blockers是如何近似的？ 如何得到average信息 MIPMAP and Summed Area Table (SAT) 优点 VSM can work with just a single, high-quality sample to determine the entire area’s eﬀect and produce a smooth penumbra 缺点 two or more occluders cover a receiver and one occluder is close to the receiver. 就是大多数occluders没有遮挡，但是有一个遮挡了，因为是求平均，所以会出现light bleeding (a.k.a. light leaks). CSM (Convolution Shadow Mapping) & ESM(Exponential Shadow Map) 把shadow函数用幂函数来建模： 然后用convolution来做filtering，这个filtering过的值就不是非0即1，有了中间值即soft shadow. Moment Shadow Mapping 基本思路 Use higher order moments to represent a distribution 基本原理 矩 缺点 Costly storage (might be fine) Costly performance (in the reconstruction) SDF(Signed Distance Field) 基本原理 不同的k决定的阴影有多soft float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) { float res = 1.0; for( float t=mint; t 优点 Fast High quality 缺点 Need precomputation Need heavy storage Artifact 复杂几何下产出的banding effects volumetric shadow technique transparency depth map The transparent objects are rendered to it, and the closest depth and color or alpha coverage is stored. 缺点是透明物体的自阴影实现不了。 deep shadow maps each shadow-map texel stores a function of how light drops oﬀ with depth. This function is typically approximated by a series of samples at diﬀerent depths, with each sample having an opacity value. 每个shadow map pixel 存若干个深度值和alpha。 opacity shadow maps，adaptive volumetric shadow maps 基本都是在deep shadow maps的基础上做了一些延伸和拓展。 var gitalk = new Gitalk({ clientID: '2eb19afceda708b27e64', // GitHub Application Client ID clientSecret: '36aedb5a30321626a8631689fee5fafd5929f612', // GitHub Application Client Secret repo: 'book', // 存放评论的仓库 owner: 'user', // 仓库的创建者， admin: ['user'], // 如果仓库有多个人可以操作，那么在这里以数组形式写出 id: location.pathname, // 用于标记评论是哪个页面的，确保唯一，并且长度小于50 }); gitalk.render('gitalk-container'); // 渲染Gitalk评论组件 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 08:40:18 "},"shadow/assignment/assignment.html":{"url":"shadow/assignment/assignment.html","title":"games202 shadow assignment","keywords":"","body":"Games202 shadow assignment1 basic shadow 1 sample PCF 50 samples with uniform disk distribution 50 samples with Poisson distribution PCSS Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-17 20:08:29 "},"ao/resource.html":{"url":"ao/resource.html","title":"AO","keywords":"","body":"Resources Real-Time Rendering chapter 11.3 11.4 RT NV 2020 Real-Time Ray-Traced Ambient Occlusion of Complex Scenes using Spatial Hashing SDF SIG 2015, Dynamic Occlusion with Signed Distance Fields Screen Space HBAO, Image-Space Horizon-Based Aambient Occlusion HBAO, 知乎论文复现 HBAO+ GTAO, SIG16 talk Practical Real-Time Strategies for Accurate Indirect Occlusion SSDO, Approximating Dynamic Global Illumination in Image Space Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-04-20 11:40:17 "},"ao/ao_summary/ao_summary.html":{"url":"ao/ao_summary/ao_summary.html","title":"Real-Time AO Summary","keywords":"","body":"Real-Time Ambient Occlusion(AO) Summary why can calculate AO separately assumptions deeper mind what is AO definition visibility function interreflections Precomputed Ambient Occlusion sampling data storage large-scale AO Dynamic Computation of Ambient Occlusion 简化模型 SDF and cone tracing voxel based screen space accumulation Screen-Space Methods screen-space ambient occlusion (SSAO) volumetric based horizon-based ambient occlusion (HBAO) ground-truth ambient occlusion (GTAO) Directional Occlusion AO不适用的场景 Solutions 非平行光 glossy BRDF screen space directional occlusion (SSDO) why can calculate AO separately AO的核心思想是把visibility计算和lighting计算分开，降低render equation计算的复杂度。 assumptions incident indirect lighting is constant diffuse materials deeper mind 为什么把cos带上，实际是转换成在投影单位圆上的积分 what is AO definition ambient occlusion a cosine-weighted percentage of the unoccluded hemisphere, 半球上的结合cos权重的归一化积分（因为带了cos所以归一化要除以 pi）。 bent normal 考虑到遮挡关系，如果用a cosine-weighted average of unoccluded light directions作为shading的normal来使用，会得到更加准确的光照计算结果。 visibility function 对于室外，室内等不同场景，visibility function的定义决定了AO的质量和性能。 ambient obscurance The value of ρ (l) is 0 at an intersection distance of 0 and 1 for any intersection distance greater than a speciﬁed distance d_max , or when there is no intersection at all. 就是在某个方向0-d_max范围内对应vis函数的值从1到0过渡。 这个虽然不是physically correct, 但效果已经还不错了，因为限制了d_max，所以性能上也会好很多，但是d_max的值需要人为设定。 interreflections AO 和 GI 最大的一个不同就是考不考虑物体之间的相互反射。 如果有遮蔽，vis = 0，那就忽略了occluder的reflection，使得有些地方过黑。 ambient obscurance 可以稍微缓解下这个问题 近似考虑interrelfections under diﬀuse illumination, the surface locations visible from a given location tend to have similar radiance. offline path tracing perform full, oﬄine path tracing for a number of scenes, each lit by a uniformly white, inﬁnitely distant environment map to obtain occlusion values. ﬁt cubic polynomials to approximate the function f that maps from the ambient occlusion value k_A and subsurface albedo ρ_ss to the occlusion value k_A′, which is brightened by the interreﬂected light. 用三次多项式去拟合AO的函数。 Precomputed Ambient Occlusion 基本的思想是基于RT, 适用于静态物。 sampling Monte Carlo importance sampling the distribution of ray directions is cosine weighted. data storage ambient occlusion ﬁeld model how the ambient occlusion value changes with distance from the object with a reciprocal of a quadratic polynomial and its coeﬃcients are stored in a cube map. ambient occlusion volume 三维贴图，存储ambient occlusion factors, and optionally the bent normal. large-scale AO a top-down view and process the resulting depth map to compute large-scale occlusion. 根据neighboring depth samples来计算AO. Dynamic Computation of Ambient Occlusion 动态物的AO没办法实时用RT的方法去做，需要做一些简化来更快的近似计算出来。 简化模型 modeling the surface as a collection of disk-shaped elements placed at the mesh vertices 之所以选择disk，是因为disk之间的遮挡关系计算是可控的。 approximate the occluding geometry as a collection of spheres 个人感觉这两个方法商用起来都有点费劲，还不如直接拿静态物的occluder来用。 SDF and cone tracing 最终的occlusion factor = cone tracing过程中的最小立体角 / cone tracing的最初立体角 a set of cones, covering the entire hemisphere global SDF & local SDF voxel based voxel GI 的时候顺带做。 screen space accumulation 对于每个object, 给出一个occlusion影响范围，在这个范围内计算物体对每个像素的occlusion影响，转换成 a proper spherical harmonic value is added to an oﬀscreen buﬀer. After accumulating visibility for all the occluders, the values in the buﬀer are exponentiated to get the ﬁnal. Screen-Space Methods screen-space ambient occlusion (SSAO) 如果已知normal，可以在半球上做结果更准确。 原算法忽略了cos项，觉得可以以cos的概率去随机选取采样点。 volumetric based where X is a three-dimensional, spherical neighborhood around the point, 考虑周围三维空间的遮挡关系，利用三维的遮挡体积比例关系计算occlusion factor. horizon-based ambient occlusion (HBAO) 基于的假设是，the data in the z-buﬀer represents a continuous heightﬁeld, 连续了才能用角度近似。 本质上是用未被遮挡的立体角除以整个半球的立体角作为occlusion factor. W这个attenuation function可以是基于距离的衰减函数。 t这个角度是该点的切平面和视线的切平面的夹角，那个黑色箭头是视线方向。 至于积分可以转换为离散采样等处理之后详细的再说说。 ground-truth ambient occlusion (GTAO) 为什么敢号称ground-truth HBAO忽略了(n dot L)项，并且还加了一项ad hoc attenuation. GTAO introduces the missing cosine factor, removes the attenuation function, and formulates the occlusion integral in the reference frame around the view vector. basic theory 注意到HBAO的分母是2 pi，但GTAO是pi, 原因就差在一个cos项上。 Directional Occlusion AO不适用的场景 会议下AO做的假设，就可以看出，AO不适用于 large area light & punctual light glossy BRDF Solutions 非平行光 light cone 和 visibility cone 求交 glossy BRDF the approximate BRDF is deﬁned as a sum of spherical Gaussians assume that the visibility function is constant across the entire support of each spherical Gaussian screen space directional occlusion (SSDO) 采样各个点，如果遮蔽，计算遮蔽处的间接光照。 这样想的话 不是 AO * direct_lighting + DO 才是最终的光照结果。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-20 17:04:14 "},"aa/resource.html":{"url":"aa/resource.html","title":"AA","keywords":"","body":"Resources TAA talk Dynamic Temporal Antialiasing in Call of Duty: Inﬁnite Warfare Temporal Antialiasing in Uncharted 4 16 Inside GDC 14 Unreal 22 new blog of TAA implementation https://github.com/playdeadgames/temporal https://github.com/h3r2tic/rtoy-samples/blob/master/assets/shaders/taa.glsl https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/TemporalAntialiasing.hlsl https://github.com/TheRealMJP/MSAAFilter/blob/master/MSAAFilter/Resolve.hlsl https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/shaders/temporalaaCS.hlsl https://gist.github.com/Erkaman/f24ef6bd7499be363e6c99d116d8734d https://github.com/GameTechDev/TAA/blob/main/MiniEngine/Core/Shaders/TAAResolve.hlsl https://github.com/PanosK92/SpartanEngine/blob/master/Data/shaders/temporal_antialiasing.hlsl https://github.com/NVIDIA/Q2RTX/blob/master/src/refresh/vkpt/shader/asvgf_taau.comp https://ziyadbarakat.wordpress.com/2020/07/28/temporal-anti-aliasing-step-by-step/ FXAA FXAA算法演义 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-04-21 13:46:07 "},"aa/aa_summary/aa_summary.html":{"url":"aa/aa_summary/aa_summary.html","title":"Real-Time AA Summary","keywords":"","body":"Real-Time antialiasing summary why AA sampling and filtering theory 熟悉的奈奎斯特采样定理 reconstruction resampling screen-based antialiasing more samples sampling patterns Morphological Methods why AA what cause aliasing Aliasing occurs when a signal is being sampled at too low a frequency sampling and filtering theory 想起了遥远的信号与系统~ 熟悉的奈奎斯特采样定理 要想信号可以被原样还原, the sampling frequency has to be more than twice the maximum frequency of the signal to be sampled, 否则还原出来的信号会混叠。 frequency 是 1 / T, 时域里变化周期的倒数。 但是rendering里的三维空间is normally never band-limited when rendered with point samples, 所以完全解决走样问题是几乎不可能的。 reconstruction resampling downsampling and upsampling screen-based antialiasing more samples 基于的宗旨基本上都是每个pixel多一些samples. SuperSampling AA 渲一个更大分辨率的，再下采样。 MSAA 每个物体对应一个像素的pixel shader只执行一次，但是一个pixel对应多个coverage samples，各个sample各取所需。 TAA 每帧相机做一些jitter，利用上一帧或前几帧的渲染结果，变相的也是多了一些samples，但是对于每一帧来说sampling的开销并没有增多。 sampling patterns 研究表明，人眼对于near-horizontal and near-vertical edges更为敏感，其次是45度对角。 RGSS（rotated grid） Halton sequence generates samples in space that appear random but have low discrepancy Quincunx sharing samples among pixels FLIPQUAD Morphological Methods 基于图像的后处理操作。 FXAA (fast approximate antialiasing) 判定哪些像素是边缘 sharp changes in brightness. 边缘像素做blend SMAA (subpixel morphological antialiasing) A logical development of the FXAA algorithm. This technique not only blurs the contrast points, but also uses a kind of logic – it finds and recognizes patterns in the form of lines, curves, boundaries of objects, and blurs them in the direction of these lines. Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-15 17:34:59 "},"texture/resource.html":{"url":"texture/resource.html","title":"Texture","keywords":"","body":"Resources Multiple Textures Texture Array DirectX11--深入理解与使用2D纹理资源 Bindless Texture DirectX12 Bindless Texture初探 Virtual Texture 浅谈virtual texture adaptive virtual texture rendering in farcry4 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-18 13:44:11 "},"texture/multiple_textures/multiple_textures.html":{"url":"texture/multiple_textures/multiple_textures.html","title":"Multiple Textures","keywords":"","body":"DirectX multiple textures texture array Texture2DArray gTexArray : register(t0); float4 PS(VertexPosHTex pIn) : SV_Target { float4 texColor = gTexArray.Sample(gSam, float3(pIn.Tex, gTexIndex)); return texColor; } inline UINT D3D11CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT MipLevels ) { return MipSlice + ArraySlice * MipLevels; } bindless texture 与传统的TextureArray不同之处在于，Shader读取时完全不对贴图在物理内存中排列有任何要求，这就意味着我们可以在一个队列中放入任意数量，任意大小，任意格式的贴图，其自由度要远高于传统的TextureArray。 Texture2D gDiffuseMap[num] : register(tX, spaceX); 这里为啥uv是乘以3采样的？？ virtual texture 基本思路是，会将纹理的mipmap chain分割为相同大小的tile或page,这里的纹理叫虚纹理，然后通过某种映射，映射到一张内存中存在的纹理，这里的纹理是物理纹理，在游戏视野发生变化的时候，一部分物理纹理会被替换出去，一部分物理纹理会被加载。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-14 22:51:18 "},"pipeline/visibility/resource.html":{"url":"pipeline/visibility/resource.html","title":"Dynamic Visibility","keywords":"","body":"Resources early-z、z-culling、hi-z、z-prepass到底是什么 文章里把z-prepass写成z-perpass了 Hill11, Practical, Dynamic Visibility for Games, hierarchical z-buffer Hierarchical-Z map based occlusion culling intel software occlusion culling GPU driven occlusion culling Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 19:37:15 "},"pipeline/visibility/dynamic_visibility_draft/draft.html":{"url":"pipeline/visibility/dynamic_visibility_draft/draft.html","title":"Dynamic Visibility Draft","keywords":"","body":"dynamic visibility solutions Static Potentially Visible Sets (PVSs) the world is discretised in some way (BSP, grid, etc.) and the binary visibility from each sector (leaf node, cell or cluster respectively) to all other sectors is pre-computed and stored. 动态物和一些可破坏物不在遮挡的计算范畴。 Hardware Occlusion Queries rendering the depth of a subset (or a simplified representation) of the scene – the occluders – and then rasterising (without depth writes，with occlusion query) the bounds of objects, or groups of objects. 古老的技术，把物体的bounding box传入得到物体是否被遮挡的结果 Hierarchical Z Buffer Render Occluder Depth Create a Depth Hierarchy Test Object Bounds 根据投影到screen上的面积来决定depth map的mip level sampler2D sHZB : register(s0); float4 main(INPUT input) : COLOR0 { float4 sbox = input.sbox; float level = input.data.x; float min_z = input.data.y; bool visible = input.data.z; float4 samples; samples.x = tex2Dlod(sHZB, float4(sbox.xy, 0, level)).x; samples.y = tex2Dlod(sHZB, float4(sbox.zy, 0, level)).x; samples.z = tex2Dlod(sHZB, float4(sbox.xw, 0, level)).x; samples.w = tex2Dlod(sHZB, float4(sbox.zw, 0, level)).x; // Modulate culling with depth test result float max_z = max4(samples); visible *= min_z Process the results 根据得到的visibility结果来决定是否剔除物体。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-21 20:27:52 "},"pipeline/cs/resource.html":{"url":"pipeline/cs/resource.html","title":"Compute Shader","keywords":"","body":"Resources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-21 20:29:00 "},"pipeline/gpudriven/resource.html":{"url":"pipeline/gpudriven/resource.html","title":"GPU Driven Rendering","keywords":"","body":"Resources prior knowledge hierarchical z-buffer bindless texture, virtual texture deferred texturing cpu occlusion culling steam compaction Blelloch, Prefix Sumsand Their Applications GPU Gems 3, Chapter 39. Parallel Prefix Sum (Scan) with CUDA compute shader directX instructions gather4 StructuredBuffer & AppendStructuredBuffer RWBuffer RWTexture2D DrawIndexedInstanced vs DrawIndexInstancedIndirect vs MultiDrawIndexedInstancedIndirect dx12 multi-indirect draw AMD driver NVIDIA driver presentations siggraph15, @ ubisoft 中文解读 上面的pdf没有说明，对于第一次接触的人看起来会比较吃力，可以先看这篇中文解说，更好接受。 gdc16, @ EA gdc18, TerrainRenderingFarCry5 @ ubisoft dragons conference 18, GPU driven Occlusion Culling 有对应的presentation pdf 和 demo source code 一些实现细节的blog part1 一些实现细节的blog part2 vulkan guide GPU driven rendering guide Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-31 15:30:13 "},"pipeline/gpudriven/oc/oc.html":{"url":"pipeline/gpudriven/oc/oc.html","title":"GPU Driven Occlusion Culling","keywords":"","body":"GPU Driven Occlusion Culling https://interplayoflight.wordpress.com/2018/05/25/gpu-driven-rendering-experiments-at-the-digital-dragons-conference/ 18年这个course的一些notes和thoughts main thoughts steps Occlusion buffer Hierarchical-Z mip chain Prop visibility calculation stream compaction MultiDrawInstancedIndirect batching mesh LOD material texture 最后附上一个针对每一步输入输出整理的XMind main thoughts using a compute shader to perform the occlusion tests producing a list of visible props consuming on the GPU to avoid rendering occluded objects using instance rendering to render the props steps Occlusion buffer render the depth of all main occluders to the occlusion buffer without pixel shader Hierarchical-Z mip chain create a Hierarchical-Z mip chain of the occlusion buffer, using the max operator to produce each mip level using a compute shader to do the downsampling void downscale(uint3 threadID : SV_DispatchThreadID) { if (all(threadID.xy gather 不支持 mip level 参数, 且只有shader model 5支持，还是用4 texture reads Prop visibility calculation packed data for instances of props in a Structured buffer world transformation axis aligned bounding box choose whether perform frustum culling compute shader to calculate visibilities 根据物体的boundingbox投影到clip space的面积大小，决定采样那一个mip level，将bdbox的八个corner的最小深度和采样得到的最大深度对比，如果最小深度>采样深度，则物体被遮挡。 for (int i = 0; i 0) && all(minXY = 0.001 ) { float mip = ceil(log2(max(size.x, size.y))); // 这里是计算mip level的地方 mip = clamp(mip, 0, MaxMipLevel); // Texel footprint for the lower (finer-grained) level float level_lower = max(mip - 1, 0); float2 scale = exp2(-level_lower); float2 a = floor(boxUVs.xy*scale); float2 b = ceil(boxUVs.zw*scale); float2 dims = b - a; // Use the lower level if we only touch stream compaction save prop visibility result as bool instanceFlagsData[threadID.x] = predicate; parallel prefix scan 如果第i个instance可见(input[i] > 0), 把这个instance的数据拷贝给压缩结果的第Output[i]个data. stream compaction 给定一个序列，如何得到前i-1个数据的和 每次将相邻两个值求和 //perform reduction for (d = NoofDrawcalls >> 1; d > 0; d >>= 1) { GroupMemoryBarrierWithGroupSync(); if (tID 再每次将序列一分为二，对比最后两个数值 以上计算可以用compute shader 并行计算，每一层需要做一次同步 //perform downsweep and build scan for (d = 1; d >= 1; GroupMemoryBarrierWithGroupSync(); if (tID 为啥最多2048个数据呢，因为一个线程组最多1024个线程，每个线程计算2个数的和，最多可以计算2048个数据。 超过2048个数据怎么办 每2048个数据使用一个compute shader thread group计算组内的累加和，然和把最大的和记到另外的数组里，之后再用一个pass, 对每个group里的数据分别加上之前所有组的最大的和 MultiDrawInstancedIndirect DX12 直接支持void ExecuteIndirect( ID3D12CommandSignature *pCommandSignature, UINT MaxCommandCount, ID3D12Resource *pArgumentBuffer, UINT64 ArgumentBufferOffset, ID3D12Resource *pCountBuffer, UINT64 CountBufferOffset ); DX11 使用NVIDIA 或者 AMD 的 driver extension nv 和 amd 还是需要把vertex 数据拍到一起 nvapiNvAPI_D3D11_MultiDrawIndexedInstancedIndirect( d3dImmediateContext, drawCount, //drawCount, renderingContext.m_instanceArgsBuffer->GetBuffer(), 0, //alignedByteOffsetForArgs 5 * sizeof(UINT) //alignedByteStrideForArgs ); DX11 除了 NVIDIA 和 AMD，使用函数封装多个DrawIndexedInstancedIndirect 或者 把所有物体生成相同顶点数的cluster，再调用DrawIndexedInstancedIndirect for (UINT i = 0; i DrawIndexedInstancedIndirect( argumentsBuffer, i * 5 * sizeof(UINT) ); } batching mesh LOD mesh cluster 这里看了一个unity的demo里的实现，是将一个object的bounding box分成多个voxel，即一个个小的立方体，然后把所有vertex根据位置对应到不同的voxel. 然后再开始分配cluster，eg. 一个cluster 255个顶点，对于一个voxel，如果>=255个顶点，把前255个顶点分配给一个cluster，如果 int loopStart = min(currentVoxel.count, max(lastedVertex - currentVoxel.count, 0)); for (int j = 0; j a); currentPoints.Add(tri->b); currentPoints.Add(tri->c); } lastedVertex -= loopStart; for (int size = 1; lastedVertex > 0; size++) { int3 leftDown = max(voxelCoord - size, 0); int3 rightUp = min(voxelSize, voxelCoord + size); for (int x = leftDown.x; x a); currentPoints.Add(tri->b); currentPoints.Add(tri->c); lastedVertex--; if (lastedVertex material single constant buffer shader 里 PerObjectData数组，size=2，可支持动态大小 texture texture array bindless texture virtual texture 最后附上一个针对每一步输入输出整理的XMind GPU driven rendering.png Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 11:16:54 "},"pipeline/cb/resource.html":{"url":"pipeline/cb/resource.html","title":"Checkerboard","keywords":"","body":"Resources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-21 20:29:00 "},"structure/framegraph/resource.html":{"url":"structure/framegraph/resource.html","title":"Frame Graph","keywords":"","body":"Resources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 15:49:37 "},"structure/ecs/resource.html":{"url":"structure/ecs/resource.html","title":"ECS","keywords":"","body":"Resources Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-07 15:49:37 "},"api/dx/multi_indirect_draw/resource.html":{"url":"api/dx/multi_indirect_draw/resource.html","title":"Multi-Indirect Draw","keywords":"","body":"Resources MaxwellGeng 知乎, DirectX 12 Multi-Indirect Draw Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-14 23:13:35 "},"special_effect/atmosphere/resource.html":{"url":"special_effect/atmosphere/resource.html","title":"Atmosphere","keywords":"","body":"Resources 一篇蛮好的blog，很多数学原理说的蛮清楚的，可以作为入门看看 UE4 egsr2020 A Scalable and Production ReadySky and Atmosphere Rendering Technique 腾讯大佬一篇对应的中文分析，把multis-cattering那部分简化的逻辑讲的比较清楚。 Bruenton 08, Precomputed Atmospheric Scattering 这老哥17年做了一版实现的优化和说明， 我觉得可以大概看下论文的思想，然后细看这个实现的说明，因为这个对于为什么可以那样预计算说的很清楚，可以跟着推导一下就很明白了。 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-07-14 14:55:16 "},"special_effect/atmosphere/ue_ray_marching/ue.html":{"url":"special_effect/atmosphere/ue_ray_marching/ue.html","title":"A Scalable and Production Ready Sky and Atmosphere Rendering Technique","keywords":"","body":"A Scalable and Production Ready Sky and Atmosphere Rendering Technique contributions artifacts leave over transmittance LUT transmittance LUT sky-view LUT aerial-perspective LUT multi-scattering LUT contributions propose a sky and aerial perspective rendering technique re-lying on LUTs to evaluate expensive parts of the lighting integralat lower resolution while maintaining important visual features. propose a novel way to evaluate the contribution of light mul-tiple scattering in the atmosphere. It can approximate an infinitenumber of scattering orders and can also be used to acceleratepath tracing. supportsdynamic time of dayalong with dynamicupdates of the atmospheric properties, all while rendering efficiently on a wide range of devices, from a low-end Apple iPhone6s to consoles and high-end gaming PCs artifacts when using very high scattering coefﬁcients, the hue can be lost or even start to drift as compared to the ground truth. we assume that the light scattering direction is isotropic right after the second bounce. This is in fact an approximation, which is conﬁrmed by a comparison between our model and the reference path tracer. For Mie scattering only, with g = 0.0 and g = 0.8, RMSE is 0.0058 and 0.039, respectively. leave over 之前的LUT的一个问题就是，有volumetric shadowing due to hills and mountains的时候会有些artifacts. epipolar lines [Yus13], shadow volumes [Bru17b], or a variant of shadow volumes extruding meshes from shadow maps [Hoo16] 云和大气包括体积雾都是涉及到volume rendering ozone 的 density 高度分布也是有特定的分布的，这个需要再看下 transmittance LUT transmittance 注意$\\beta$的定义， represent the ratio of light that is lost by interactions with a particle. LUT 任何一点以任一角度到大气边界的transmittance，可以最终转换成以r, $cos(\\theta)$为变量的函数表示 Length ComputeOpticalLengthToTopAtmosphereBoundary( IN(AtmosphereParameters) atmosphere, IN(DensityProfile) profile, Length r, Number mu) { assert(r >= atmosphere.bottom_radius && r = -1.0 && mu = atmosphere.bottom_radius && r = -1.0 && mu 从camera到任意距离的transmittance, 除法关系 DimensionlessSpectrum GetTransmittance( IN(AtmosphereParameters) atmosphere, IN(TransmittanceTexture) transmittance_texture, Length r, Number mu, Length d, bool ray_r_mu_intersects_ground) { assert(r >= atmosphere.bottom_radius && r = -1.0 && mu = 0.0 * m); Length r_d = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r)); Number mu_d = ClampCosine((r * mu + d) / r_d); if (ray_r_mu_intersects_ground) { return min( GetTransmittanceToTopAtmosphereBoundary( atmosphere, transmittance_texture, r_d, -mu_d) / GetTransmittanceToTopAtmosphereBoundary( atmosphere, transmittance_texture, r, -mu), DimensionlessSpectrum(1.0)); } else { return min( GetTransmittanceToTopAtmosphereBoundary( atmosphere, transmittance_texture, r, mu) / GetTransmittanceToTopAtmosphereBoundary( atmosphere, transmittance_texture, r_d, mu_d), DimensionlessSpectrum(1.0)); } } sky-view LUT resolution: 192 * 108 u v 含义 其实是建立了以 天顶方向为z轴， 太阳在垂直于天顶方向的平面的向量为x轴的坐标系。 不管观察位置怎么变，根据viewZenithCosAngle和ZenithHorizonAngle进行归一化，始终在sky-view LUT的上半平面或者下半平面采样。 这样到了外太空需要每帧ray-marching计算。 void SkyViewLutParamsToUv(AtmosphereParameters Atmosphere, in bool IntersectGround, in float viewZenithCosAngle, in float lightViewCosAngle, in float viewHeight, out float2 uv) { float Vhorizon = sqrt(viewHeight * viewHeight - Atmosphere.BottomRadius * Atmosphere.BottomRadius); float CosBeta = Vhorizon / viewHeight; // GroundToHorizonCos float Beta = acos(CosBeta); float ZenithHorizonAngle = PI - Beta; if (!IntersectGround) { float coord = acos(viewZenithCosAngle) / ZenithHorizonAngle; coord = 1.0 - coord; #if NONLINEARSKYVIEWLUT coord = sqrt(coord); // more samples near horizon #endif coord = 1.0 - coord; // dx uv (0, 0) left top uv.y = coord * 0.5f; } else { float coord = (acos(viewZenithCosAngle) - ZenithHorizonAngle) / Beta; #if NONLINEARSKYVIEWLUT coord = sqrt(coord); #endif uv.y = coord * 0.5f + 0.5f; } { float coord = -lightViewCosAngle * 0.5f + 0.5f; // left and right is symmetrical coord = sqrt(coord); uv.x = coord; } // Constrain uvs to valid sub texel range (avoid zenith derivative issue making LUT usage visible) uv = float2(fromUnitToSubUvs(uv.x, 192.0f), fromUnitToSubUvs(uv.y, 108.0f)); } aerial-perspective LUT 3d texture resolution 32 32 32, 32depth = 32 km In-scattering is stored in the RGB channels while the transmittance is stored in the A channel, as the mean of the wavelength dependent RGB transmittance. 绘制LUT的时候，camera的位置为(0, 0, 0), 感觉之后即使位置变了，也是根据这个粗略算的（FASTAERIALPERSPECTIVE_ENABLED）。或者就是每帧都重新算。 multi-scattering LUT 含义 应该希望得到视线方向的积分路径上任意某一点的高阶散射luminance, 在该点会进行最后一次散射(散射后光的传播方向会变成视线方向的反方向)。 2d texture resolution 32 * 32 u v 含义 u是阳光反方向的天顶角cos值，v值是离地球半径高度的归一化值。 assumptions 2阶及2阶以上的multi-scattering在计算时假设是各向同性的，相位函数是一个常量(1 / 4pi) 计算大于2阶的散射时，所有路径上点收到的2阶散射光illuminance是相等的 忽略可见性 float3 GetMultipleScattering(AtmosphereParameters Atmosphere, float3 scattering, float3 extinction, float3 worlPos, float viewZenithCosAngle) { float2 uv = saturate(float2(viewZenithCosAngle*0.5f + 0.5f, (length(worlPos) - Atmosphere.BottomRadius) / (Atmosphere.TopRadius - Atmosphere.BottomRadius))); uv = float2(fromUnitToSubUvs(uv.x, MultiScatteringLUTRes), fromUnitToSubUvs(uv.y, MultiScatteringLUTRes)); float3 multiScatteredLuminance = MultiScatTexture.SampleLevel(samplerLinearClamp, uv, 0).rgb; return multiScatteredLuminance; } 把texture的u和v分成8*8个线程组进行计算。 auto DispatchCS = [&](UINT w, UINT h) { uint32 DispatchSizeX = w;// divRoundUp(w, 8); uint32 DispatchSizeY = h;// divRoundUp(h, 8); uint32 DispatchSizeZ = 1; context->Dispatch(DispatchSizeX, DispatchSizeY, DispatchSizeZ); }; 这里是对某一个高度和太阳天顶角，用compute shader把积分的方向4pi分成了64个采样方向进行求和。 各个方向的2阶散射illuminance存在MultiScatAs1SharedMem. numthreads(1, 1, 64)] void NewMultiScattCS(uint3 ThreadId : SV_DispatchThreadID) { float2 pixPos = float2(ThreadId.xy) + 0.5f; float2 uv = pixPos / MultiScatteringLUTRes; uv = float2(fromSubUvsToUnit(uv.x, MultiScatteringLUTRes), fromSubUvsToUnit(uv.y, MultiScatteringLUTRes)); AtmosphereParameters Atmosphere = GetAtmosphereParameters(); float cosSunZenithAngle = uv.x * 2.0 - 1.0; float3 sunDir = float3(0.0, sqrt(saturate(1.0 - cosSunZenithAngle * cosSunZenithAngle)), cosSunZenithAngle); // We adjust again viewHeight according to PLANET_RADIUS_OFFSET to be in a valid range. float viewHeight = Atmosphere.BottomRadius + saturate(uv.y + PLANET_RADIUS_OFFSET) * (Atmosphere.TopRadius - Atmosphere.BottomRadius - PLANET_RADIUS_OFFSET); float3 WorldPos = float3(0.0f, 0.0f, viewHeight); float3 WorldDir = float3(0.0f, 0.0f, 1.0f); const bool ground = true; const float SampleCountIni = 20;// a minimum set of step is required for accuracy unfortunately const float DepthBufferValue = -1.0; const bool VariableSampleCount = false; const bool MieRayPhase = false; const float SphereSolidAngle = 4.0 * PI; const float IsotropicPhase = 1.0 / SphereSolidAngle; // 八进制来组合theta和phi的index，一位用来做theta的index，一位用来做phi的index // Reference. Since there are many sample, it requires MULTI_SCATTERING_POWER_SERIE to be true for accuracy and to avoid divergences (see declaration for explanations) #define SQRTSAMPLECOUNT 8 const float sqrtSample = float(SQRTSAMPLECOUNT); float i = 0.5f + float(ThreadId.z / SQRTSAMPLECOUNT); // 加上0.5/8的角度偏移 float j = 0.5f + float(ThreadId.z - float((ThreadId.z / SQRTSAMPLECOUNT)*SQRTSAMPLECOUNT)); { float randA = i / sqrtSample; float randB = j / sqrtSample; float theta = 2.0f * PI * randA; float phi = PI * randB; float cosPhi = cos(phi); float sinPhi = sin(phi); float cosTheta = cos(theta); float sinTheta = sin(theta); WorldDir.x = cosTheta * sinPhi; WorldDir.y = sinTheta * sinPhi; WorldDir.z = cosPhi; SingleScatteringResult result = IntegrateScatteredLuminance(pixPos, WorldPos, WorldDir, sunDir, Atmosphere, ground, SampleCountIni, DepthBufferValue, VariableSampleCount, MieRayPhase); MultiScatAs1SharedMem[ThreadId.z] = result.MultiScatAs1 * SphereSolidAngle / (sqrtSample * sqrtSample); LSharedMem[ThreadId.z] = result.L * SphereSolidAngle / (sqrtSample * sqrtSample); } #undef SQRTSAMPLECOUNT // 这里是在把这些值通过二分法累加到第0个元素上 GroupMemoryBarrierWithGroupSync(); // 64 to 32 if (ThreadId.z 0) return; float3 MultiScatAs1 = MultiScatAs1SharedMem[0] * IsotropicPhase; // Equation 7 f_ms float3 InScatteredLuminance = LSharedMem[0] * IsotropicPhase; // Equation 5 L_2ndOrder // MultiScatAs1 represents the amount of luminance scattered as if the integral of scattered luminance over the sphere would be 1. // - 1st order of scattering: one can ray-march a straight path as usual over the sphere. That is InScatteredLuminance. // - 2nd order of scattering: the inscattered luminance is InScatteredLuminance at each of samples of fist order integration. Assuming a uniform phase function that is represented by MultiScatAs1, // - 3nd order of scattering: the inscattered luminance is (InScatteredLuminance * MultiScatAs1 * MultiScatAs1) // - etc. #if MULTI_SCATTERING_POWER_SERIE==0 float3 MultiScatAs1SQR = MultiScatAs1 * MultiScatAs1; float3 L = InScatteredLuminance * (1.0 + MultiScatAs1 + MultiScatAs1SQR + MultiScatAs1 * MultiScatAs1SQR + MultiScatAs1SQR * MultiScatAs1SQR); #else // For a serie, sum_{n=0}^{n=+inf} = 1 + r + r^2 + r^3 + ... + r^n = 1 / (1.0 - r), see https://en.wikipedia.org/wiki/Geometric_series // 这里用了论文里拖到的简化公式来计算的 const float3 r = MultiScatAs1; const float3 SumOfAllMultiScatteringEventsContribution = 1.0f / (1.0 - r); float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;// Equation 10 Psi_ms #endif OutputTexture[ThreadId.xy] = float4(MultipleScatteringFactor * L, 1.0f); } Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-22 08:27:49 "},"special_effect/atmosphere/multi_scattering/multi_scattering.html":{"url":"special_effect/atmosphere/multi_scattering/multi_scattering.html","title":"multi-scattering计算的一些思考","keywords":"","body":"multi-scattering计算的一些思考 multi-scattering计算的一些思考 从遇到的线上崩溃说起 背景 UE4 新的大气渲染做的multi-scattering简化 优化的方案 从遇到的线上崩溃说起 背景 最近新的赛季上线，有一部分低端配置的玩家报上来说切换了选角界面之后游戏崩溃。万幸的是，有一个同事的笔记本(NVIDIA 750M)可以必现这个问题。后来在复现的过程中发现，切换选角界面再回到游戏中时，大气的效果变了。。于是大概确定是我之前做的大气的锅。我本地调试时发现每次切换选角界面，因为一些配置的缘故，都会切换到我实现的的Bruenton17年的那版算法，可是在我的机器上却并不会崩溃，而且根据玩家的反馈看，只有部分低端机器会有崩溃现象。 于是只能把同事的笔记本“强行征用”，通过增加日志和二分排除pass法等手段，最后发现崩溃就是发生在切换算法时，会重新进行新的预计算(一帧完成)，而预计算如果的multi-scattering迭代超过3阶，GPU计算时间过长，CPU端以为GPU“有问题”了，于是出于保护强行崩溃了。 error: DXGI_ERROR_DEVICE_REMOVED DXGI_ERROR_DEVICE_HUNG 总结得出以下： 以后写了新的功能但并不希望pipeline跑到的时候，配置要十分注意 precompute的multi-scattering很消耗性能，对于低配机来说，如果强行一帧算完，会导致崩溃 于是乎眼下要做的就是优化precompute的性能。忽而想起之前看的UE4的paper有对multi-scattering的简化，于是又翻出来看了看。 UE4 新的大气渲染做的multi-scattering简化 UE4的A Scalable and Production ReadySky and Atmosphere Rendering Technique中基于一定的假设对multi-scattering的计算进行了简化，使得不再需要进行高阶的迭代得到一个比较好的结果。 推导过程如下： ps: 写了个错别字，相位函数。。 优化的方案 总结以上，而且我们游戏目前还是基于地球环境的近地面居多，想到了两种优化方案： 还是用precompute的multi-scattering迭代计算方法，但是分帧计算，这个方法已经在同事的笔记本上试过，可行，但可能有个短暂的预计算时间。 用UE4 paper中的简化计算方法，但做一些改变，即生成一张multi-scattering LUT，在之前precompute的二阶 scattering计算的最后，计算出无穷阶的scattering结果，累加到single scattering上。下周可以实现下这个方案，看下大气的效果如何const float3 r = MultiScatAs1; const float3 SumOfAllMultiScatteringEventsContribution = 1.0f / (1.0 - r); 预计算multi-scattering transfer的时候只计算 MultiScatAs1 Bruenton17 在第二阶multi scattering的第一步 compute the delta_scattering_density_texture的时候 * 1.0f / (1.0 - r) 采样multi-scattering transfer贴图的时候，u是太阳的天顶角cos值，v是相机离地面高度 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-29 07:57:38 "},"special_effect/cloud/resource.html":{"url":"special_effect/cloud/resource.html","title":"Cloud","keywords":"","body":"Resources courses GPU pro 7, Real-Time Volumetric Cloudscapes 15 siggraph course, The Real-time Volumetric Cloudscapes of Horizon: Zero Dawn 17 siggraph course, Nubis: Authoring Real-Time Volumetric Cloudscapes with the Decima Engine 19 siggraph course, Creating the Atmospheric World of Red Dead Redemption 2: A Complete and Integrated Solution ea Frosbite, Physically Based Sky, Atmosphere & Cloud Rendering 2020, Stormscapes: Simulating Cloud Dynamics in the Now implementation Volume Cloud for Unity3D Implementation of Horizon: Zero Dawn's cloud renderer Experiment with generating clouds in real time on low end computer Vulkan-based implementation of clouds from Decima Engine ea_16_cloud Real-time rendering of volumetric clouds FORUM Horizon:zero Dawn Cloud System Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-07-05 15:08:17 "},"simulation/resource.html":{"url":"simulation/resource.html","title":"Simulation","keywords":"","body":"Resources lessons games 103, 基于物理的计算机动画入门 课程主要涵盖四个方向，分别为：1）刚体模拟；2）质点弹簧、约束与布料模拟；3）基于有限元的弹性体模拟；4）流体模拟 games 201, Advanced Physics Engines 基于Taichi物体引擎的关于物理仿真的进阶课程，课程内容包含： Lagrangian/Eulerian/hybrid views; Mass-spring systems; Explicit/implicit time integrators; Smoothed particle hydrodynamics; Implicit FEM solvers; Chorin-Style projection; Krylov-subspace solvers; Multigrid preconditioning; Topology optimization; PIC/FLIP/APIC; Material Point Method; MLS-MPM; Plasticity; High-performance computing; Differentiable physical simulation. Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-03-09 16:26:07 "},"simulation/fluid/resource.html":{"url":"simulation/fluid/resource.html","title":"Fluid","keywords":"","body":"Resources 毛星云，真实感水体渲染技术总结 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-03-09 16:04:56 "},"course/resource.html":{"url":"course/resource.html","title":"Course","keywords":"","body":"Resources UC Davis 2009, computer graphics 最早我开始学图形学的时候看的课程，课程比较老还是手写黑板教学，虽然都是很初级的知识，但是老师讲的蛮好的，不是照本宣科，说明白里里面的一些道理。 games 101 games 202 UCSD CSE 272: Advanced Image Synthesis UCSD CSE 168 Computer Graphics II: Rendering 台湾大学，Digital Image Synthesis, Fall 2016 图形学基础 09/22 overview 09/22 core 09/29 geometry 09/29 shapes 10/06 accelerators 10/20 color and radiometry 10/27 camera 11/03 sampling 11/10 reflection models 11/17 materials 11/17 textures 11/24 lights 12/01 Monte Carlo I 12/15 Monte Carlo II 12/22 surface integrator 01/05 participating media Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 11:45:26 "},"course/UC_Davis_Computer_Graphics/UC_Davis_Computer_Graphics.html":{"url":"course/UC_Davis_Computer_Graphics/UC_Davis_Computer_Graphics.html","title":"UC Davis Compute Graphics","keywords":"","body":"UC Davis Computer Graphics UC Davis Computer Graphics Ref Affine Transformation Curves in plane move objects in space Rotations around an arbitrary axis the camera transform Shading and Texturing Visible surface algorithm Ray Tracing Subdivision Surface Shadows part Camera motion Branches of CG Ref 视频 https://www.youtube.com/watch?v=0NbD-c0Ctdk&list=PL_w_qWAQZtAZhtzPI5pkAtcUVgmzdAP8g&index=2 Affine Transformation vector space Curves in plane subdivision curve, Chaikin's Algorithm control point 1/4 3/4 again and again go througn mid-point 反过来 pick some points tan line 3d does not work Bezier Curve attract point B-spline curve continuous->derivative equal bezier vs spline 使用n = 3的贝塞尔曲线原因是要限定相邻的两个分段多项式，在交接点位置的一阶导数相等（斜率相等）和二阶导数相等（斜率的变化率相等） move objects in space a point in space translation scaling center is not in origin, then scaling will cause translation rotate 3d rotate around z axis Rotations around an arbitrary axis model-view-controller easy to debug Rotate around rotate 一个点 一个向量(arbitrary axis）rotate some angles 怎么旋转：把这个点平移到原点，向量旋转到和eg. z axis重合，rotate some angles，再反着做回来 translation 投影 rotate -theta, rotate fi reverse 4d projective point parabola 抛物线 project down as a circle rational splines 有理样条 simulate a camera the camera transform viewing transform pinhole camera camera point direction vector / center of attention up direction angle of view near and far distances 找到一种转换方式把3d的世界转换成视角的2d图像 pyramid -> cube(image space)-> square(screen space) (修正 image space 正负坐标反了) (修正+n， +f) （0, n*tan(a/2), -n）-> (1,1) image space real world Clipping find the real interesting spaces - \"in\" ps. polygon convex, 连接任意两条边的线段都在区域内non-convex -> split into convex pieces glu lookat vs glu perspective glulookat void gluLookAt ( GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz); 定义了观察者的做坐标，视野中心点在世界坐标系的位置 & 相机的朝向 glu perspective void gluPerspective ( GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar); 定义了相机的内在参数，可视角大小， 物体显示在canvas上的x和y方向上的比例，第三个参数zNear,定义距离相机（人眼）最近处物体截面相距的距离。这个值越大，表示观测点距离物体距离越远，看起来物体就比较小，反之则比较大。如果物体运动到距离观测点的距离小于了设定的zNear,则物体不会被绘制在画板上。 第四个参数zFar,定义可观测到的物体的最远处截面相距相机的距离。如果物体运动到距离观测点的距离大于了设定的zFar,则物体不会被绘制的画板上。 do clipping in image space Depth Buffers and Ray Tracing ？something is in front of another image space judge by z coordinates depth buffer 存储最近的物体的深度 如果object的深度大于z buffer的值，不绘制 Ray Tracing painter's algorithm 画家算法首先将场景中的多边形根据深度进行排序，然后按照顺序进行描绘 Color and Shading color lights background light (ambient light) is a constant Lambert's Law reflect base color n is glossness l input, v output h= l+v/2, h 和 n (法线) 夹角越小，反射的光越强 Quaternions rotations structure data on disk? extension of complex 不满足交换律 Unit quaternions rotate around vector v, rotate theta angle ps. 欧拉旋转: Gimbal Lock问题的核心还是在于我们采用了固定的旋转顺序 四元数: chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=https%3A%2F%2Fkrasjet.github.io%2Fquaternion%2Fquaternion.pdf Shading and Texturing shading 着色 b means base color -> texturing 10 hyper parameters direct light / spot light -> l change or not n bump mapping ploygons flat shading (平面着色) one color Gouraud Shading -> average color phong shading -> average normal texturing 纹理 texture mapping -> interpolate The hierarchical modeling system how to model things model one thing -> transform to another polygon -> commands not only drawing things -> but also building things Scan Conversion device space split polygon into trapezoids edge track endpoint other staff: light sources Warnock's algorithm Curves and surfaces Chaikin's Algorithm Chaikin's Curve -> control points 1/4 3/4 (fix ratio), initial point may not on the curve 3d surface -> two pairs of control points -> subdivision algorithms Bezier Patch Bezier curve 1/2 initial point is on the curve control points coplanar convex hull property 凸包， curve is not getting away from u variation diminishing 变差缩减性，不会来回摆动 slope at p0 is equal to p0p1, first derivative how about second derivative NURBS non uniform rational Bspline NUBS limit degree of curves Bezier surface four corners on the surface Bezier curves as boundary Visible surface algorithm Painter's algorithm paint all from back to front Binary Tree Sort BSP - trees moving camera position, just move subtree left to right Warnock's algorithm Ray Tracing how it do eye position -> pixel trace to the nearest point first paper reflect shadow refract forward & backward ray tracing backward ray tracing may miss things calculate the nearest point Subdivision Surface Chaikin's Curve Chaikin's Surface/Doo-Sabin Surface 不同方向上做1/4 3/4（Chaikin's points），连接，划分成一个个小的mesh how to save such data ? -> split edge a pointer -> start point a pointer -> next edge a pointer -> neighbor subEdge Catmull-Clark Subdivision loop subdivision (triangle meshes) vertex point (half way half way)& edge point (mid point) Face point: F = average of all points defining the face Edge point: E = average of tow adjoining face points and the two vertices Vertex point: V = (average of all face points + average of all edge poins + constant origin vectors )/ 4 how to model sphere -> triangle data structure: 3 vertexes + 3 pointers to neighbors Shadows part ground plane (need a point and a normal) avoid sharp shadows -> texture with fuzzy edge polygons too complex -> general bounding box shadow volumes count numbers of into a shadow volumes (+1) and out of a shadow volumes (-1) sum = zero : no shadows ps. umbra penumbra depth buffer shadows for each light source, create a \"picture\" (image space, z buffer) for each eye point, create a \"picture\" (z buffer) reconcile these pictures Camera motion simulate camera motion path as smooth curve Lagrange interpolation spline Ferguson curve Catmull 二次导等于间隔点连线 c1 连续 curve ps Branches of CG Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-02-28 11:12:04 "},"course/UCSD_CSE_272_part1/part1.html":{"url":"course/UCSD_CSE_272_part1/part1.html","title":"Intro & Simple BSDF","keywords":"","body":"UCSD CSE 272 : Advanced Image Synthesis --- intro & simple BSDF part UCSD CSE 272 : Advanced Image Synthesis --- intro & simple BSDF part intro course overview smallpt : path tracing in 30 minutes What is the color of a pixel? what‘s more lajolla geometry primitive next event estimation multi importance sampling textures shading normals embree BSDF how to obtain BSDF build a model for BSDF Microfacet theory Uber BSDF Uber BSDF Disney BSDF Autodesk Standard Surface Unreal Engine 4 Physically-based Material Normal/Displacement Map Filtering mipmap normal map --- using NDF principle solutions LEAN LEADR Yan Ling-Qi --- 还原复杂normal下的高光 procedurally generate normals more researches intro course overview smallpt : path tracing in 30 minutes What is the color of a pixel? reconstruction path tracing intersection trace diffuse relfection mirror reflection refraction lighting termination what‘s more lajolla geometry primitive struct Sphere : public ShapeBase { Vector3 position; Real radius; }; struct TriangleMesh : public ShapeBase { /// TODO: make these portable to GPUs std::vector positions; std::vector indices; std::vector normals; std::vector uvs; /// Below are used only when the mesh is associated with an area light Real total_area; /// For sampling a triangle based on its area TableDist1D triangle_sampler; }; // To add more shapes, first create a struct for the shape, add it to the variant below, // then implement all the relevant functions below. using Shape = std::variant; next event estimation in addition to cosine-weighted hemisphere sampling, also sample a point on light light sampling struct pdf_point_on_shape_op { Real operator()(const Sphere &sphere) const; Real operator()(const TriangleMesh &mesh) const; const PointAndNormal &point_on_shape; const Vector3 &ref_point; }; multi importance sampling textures 用一阶Taylor展开来根本的解释mip map level原理 path tracing 怎么计算偏导数 ```cpp /// We adopt an approach for ray differentials /// that is used in Renderman. /// See Section 6.6 in \"RenderMan: /// An Advanced Path Tracing Architecture for Movie Rendering\" /// https://graphics.pixar.com/library/RendermanTog2018/paper.pdf /// The idea is to simplify Igehy's ray differential by only /// storing two quantities: a \"radius\" that describes positional /// differential, and a \"spread\" that describes directional differential. /// For glossy/diffuse surfaces, Renderman used a heuristics based on the /// PDF of the sampling direction and use larger spread for low PDF. /// Here we use an even simpler heuristics: we linearly blend /// between the specular spread and a constant based on roughness. struct RayDifferential { // Radius is approximately (length(dp/dx) + length(dp/dy)) / 2 // Spread is approximately (length(dd/dx) + length(dd/dy)) / 2 // p is ray position, d is ray direction. Real radius = 0, spread = 0; // The units are pixels. }; ``` shading normals chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=https%3A%2F%2Fjo.dreggn.org%2Fhome%2F2021_terminator.pdf embree BSDF how to obtain BSDF build a model for BSDF Microfacet theory normal distribution function microsurface geometry profile Fresnel --- ratio of reflection complex for metals multiple scattering Uber BSDF This “Uber” BSDF includes multiple layers to create a wide variety of materials. Uber BSDF Disney BSDF diffuse metal & clear coat glass sheen Autodesk Standard Surface clear coat metal sheen Unreal Engine 4 Physically-based Material Normal/Displacement Map Filtering mipmap normal map --- using NDF principle 核心思想是通过局部的normal map 来推导出NDF分布 solutions LEAN 拟合 Beckmann NDF 这个难道不就是specular AA ？？ 拟合 geometry term result LEADR displacement and reflectance mapping Yan Ling-Qi --- 还原复杂normal下的高光 核心思想是 count texels on the normal map given and ω ω′ 实际是用Guassian distribution来拟合normal朝向的权重 procedurally generate normals more researches Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-04-06 14:23:50 "},"course/UCSD_CSE_272_part2/part2.html":{"url":"course/UCSD_CSE_272_part2/part2.html","title":"Advanced BSDF","keywords":"","body":"UCSD CSE 272 : Advanced Image Synthesis --- advanced BSDF Layered BSDF a comprehensive framework for rendering layered materials basic principle special case : pile of glass plates [Stokes 1860] general case : adding equation [Grant and Hunt 1969] general layered BSDF construction [Jakob 2014] Efficient Rendering of Layered Materials using an Atomic Decomposition with Statistical Operators basic principle Belcour’s algorithm Position-Free Monte Carlo Simulation for Arbitrary Layered BSDFs basic principle recent research Hair and Cloth physical structures hair rendering categories strand-based models [Marschner et al. 2003] modeling the geometry of hair strands ray-curve intersection hair BSDF cloth rendering categories Wave-based BSDFs what is light why do we see things Huygen’s principle real-life wave optics effects Wave BSDF in computer graphics thin-film BSDF adding diffraction in microfacet models Other wave optics work Layered BSDF how to modeling layered BSDF a comprehensive framework for rendering layered materials http://www.cs.cornell.edu/projects/layered-sg14/ basic principle adding equation: 把每一层的光照作用累积起来 special case : pile of glass plates [Stokes 1860] general case : adding equation [Grant and Hunt 1969] general layered BSDF construction [Jakob 2014] use a Fourier basis to compress the matrices https://www.pbr-book.org/3ed-2018/Reflection_Models/Fourier_Basis_BSDFs downside need to store a huge sparse matrix (in Fourier domain) texturing is hard Efficient Rendering of Layered Materials using an Atomic Decomposition with Statistical Operators basic principle use sum of GGX lobes to represent multiple scattering between layers approximate the R&T matrices using Gaussians for a given direction ω Belcour’s algorithm each layer energy mean variance add all of layers Position-Free Monte Carlo Simulation for Arbitrary Layered BSDFs basic principle just compute the multiple scattering using Monte Carlo integration 降维 the horizontal distance doesn’t matter in a BSDF solve a small “1D” rendering equation inside the material recent research Hair and Cloth physical structures made of fibers hair rendering categories strand-based models [Marschner et al. 2003] modeling the geometry of hair strands option1 --- polylines(多线段) but lines don’t have thickness! option 2 --- connected cylinders(圆柱) rendering cylinders is a bit expensive option 3 --- connected quads(有点类似于billboard的四边形) quads always face towards the viewers use shading normal to fake cylinder appearances option 4 --- connected Bezier curves smoother appearance and less storage cost can use either the planar approximation or have actual cylindrical shape can use shading normal to represent orientation variation within the curve ray-curve intersection hair BSDF or “BCSDF” (Bidirectional Curve Scattering Distribution Function) or “BFSDF” (F=Fiber) lighting model use a lobe for each scattering mode Common assumption: separable lobes for longitudinal & azimuthal longitudinal scattering Marschner et al. [2003]: fit different wrapped Gaussians around the half-angle d’Eon et al. [2011]’s proposal: use a von-Mises-like distribution http://www.eugenedeon.com/wp-content/uploads/2014/04/egsr azimuthal scattering Common assumption: the circular section is isotropic (i.e. it’s not an ellipse) Chiang et al. [2016] proposed to use a logistic distribution volumetric absorption and Fresnel 3 lobes for R, TRT, TT; 1 lobe to compensate energy Bells and whistles(really interesting) 动物毛发和人类毛发的差别: volumetric scattering 不同人种真实的头发截面形状: elliptical cross section 不区分longitudinal和azimuthal: non-separable lobes real-time rendering cloth rendering categories 如果感兴趣，再找对应的paper深入了解下 Wave-based BSDFs what is light why do we see things Huygen’s principle 用复数来表示波 real-life wave optics effects compact disks caused by many small “slits” soap bubbles caused by “thin-film interference” dispersion(色散) hologram(全息图) Wave BSDF in computer graphics thin-film BSDF idea replace the Fresnel term in Cook-Sparrow-Torrance adding diffraction in microfacet models Other wave optics work Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 13:47:03 "},"engine/filament/resource.html":{"url":"engine/filament/resource.html","title":"Filament","keywords":"","body":"Resources PBR Physically Based Rendering in Filament, 官方文档 对应的中文翻译 Filament Materials Guide, 官方材质文档 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-01 20:30:41 "},"engine/ue/resource.html":{"url":"engine/ue/resource.html","title":"Unreal","keywords":"","body":"Resources PBR Real Shading inUnreal Engine 4 Copyright © tingxia.top 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-01 20:30:20 "}}